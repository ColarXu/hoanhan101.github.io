{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hoanh An",
    "home_page_url": "/",
    "feed_url": "/feed.json",
    "description": "Hoanh An's personal website",
    "icon": "/apple-touch-icon.png",
    "favicon": "/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "Hoanh An",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "/2019/10/08/leetcode-array-string",
            "title": "LeetCode's Array/String",
            "summary": null,
            "content_text": "1. Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.Example:- Input: nums = []int{2, 5, 4}, target = 6  Output: [0, 2] since nums[0] + nums[2] = 2 + 4 = 6Approach:- Use a hash map to store the value and its index as we iterate through the  list.- Within each iteration, look up the difference of target and the current  value to see if we have seen that number.- Simply return two cached indices once that condition meets.Cost:- O(n) time, O(n) space.Link to solution →2. Given a sorted array of integers, return indices of the two numbers such that they add up to a specific target.Example:- Input: nums = []int{2, 3, 4}, target = 6  Output: [0, 2] since nums[0] + nums[2] = 2 + 4 = 6Approach:- Since the array is sorted, can use two-pointer approach that has one point  to the start of the list while the other point at the end and move the  toward each other.Cost:- O(n) time and O(1) space.Link to solution →3. Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.Example:- Input: \"A man, a plan, a canal: Panama\"  Output: true- Input: \"race a car\"  Output: falseApproach:- Use two pointers approach that have one point to the start of the string and  the other point at the end.- Move them toward each other and compare if they're the same characters while  skipping non-alphanumeric characters and ignoring cases.Cost:- O(n) time, O(1) space.Link to solution →4. Implement strstr() that finds the first occurrence of the substring needle in the string haystack. It returns -1 if needle is not part of the haystack.Example:- Input: haystack = \"aaabacd\", needle = \"ba\"  Output: 3, because needle \"ba\" starts at index 3 in the haystack.Approach:- Scan the needle with the haystack from its first position and start matching  all subsequent letters one by one.- If one letter does not match, start again with the next position in the  haystack.Cost:- O(nm) time, O(1) space, where n is the length of haystack while m is the  length of needle.Link to solution →5. Given a string, reverse it word by word.Example:- Input: \"hard so be to have not does interview coding\"  Output: \"coding interview does not have to be so hard\"Approach:- Approach with a two-pass solution.- The first pass is to split the string into an array of words separated by  spaces.- The second pass is to reverse the order of words in the array by using  two-pointer approach: swap two values on both ends as we move toward the  middle.- Concatenate the values of ordered array to create a final string.Cost:- O(n) time, O(n) space.Link to solution →6. Given a string, find the length of the longest substring without repeating characters.Example:- Input: \"abcabcbb\"  Output: 3  Explanation: The longest substring is \"abc\" with the length of 3.- Input: \"bbbbb\"  Output: 1  Explanation: The longest substring is \"b\" with the length of 1.Approach:- Iterate through the string and keep track of the maximum length of non-repeating  characters using a hashmap that maps characters to their indices.- Could skip characters immediately if we found a repeating character.Cost:- O(n) time, O(m) cost where m &lt; n and  n is the length of the string.Link to solution →7. Given a sorted integer array where the range of elements are [0, 99] inclusive, return its missing ranges.Example:- Input: []int{0, 1, 6, 16, 66, 99}  Output: []string{\"2-5\", \"7-15\", \"17-65\", \"67-98\"}- Input: []int{6, 16, 66}  Output: []string{\"0-5\", \"7-15\", \"17-65\", \"67-99\"}Approach:- Keep two pointers where one is ahead of the other by 1 index.- Iterate through the list, calculate the difference of two consecutive numbers  in the list at each step and append it to a new list.Cost:- O(n) time, O(m) space, where m &lt; n and n is the size of the input.Link to solution →8. Given two strings, determine if they are both one edit distance apart.Example:- Input: \"abcde\", \"abXde\"  Output: true  Explanation: Only \"c\" in S is replaced by \"X\" in T.- Input: \"abcde\", \"abcXde\"  Output: true  Explanation: \"X\" is inserted between \"c\" and \"d\" in S to get T.Approach:- Use two-pointer approach to traverse both strings at the same time and  keep track of count of difference characters.Cost:- O(n) time, O(1) spaceLink to solution →  For more coding problems, please visit  https://github.com/hoanhan101/algo.  If you’re interested in getting updates for such content like these, consider  joining my mail list here →",
            "content_html": "<h3 id=\"1-given-an-array-of-integers-return-indices-of-the-two-numbers-such-that-they-add-up-to-a-specific-target\">1. Given an array of integers, return indices of the two numbers such that they add up to a specific target.</h3><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: nums = []int{2, 5, 4}, target = 6  Output: [0, 2] since nums[0] + nums[2] = 2 + 4 = 6</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use a hash map to store the value and its index as we iterate through the  list.- Within each iteration, look up the difference of target and the current  value to see if we have seen that number.- Simply return two cached indices once that condition meets.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(n) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/leetcode/two_sum_i_test.go\">Link to solution →</a></p><h3 id=\"2-given-a-sorted-array-of-integers-return-indices-of-the-two-numbers-such-that-they-add-up-to-a-specific-target\">2. Given a sorted array of integers, return indices of the two numbers such that they add up to a specific target.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: nums = []int{2, 3, 4}, target = 6  Output: [0, 2] since nums[0] + nums[2] = 2 + 4 = 6</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Since the array is sorted, can use two-pointer approach that has one point  to the start of the list while the other point at the end and move the  toward each other.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time and O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/leetcode/two_sum_ii_test.go\">Link to solution →</a></p><h3 id=\"3-given-a-string-determine-if-it-is-a-palindrome-considering-only-alphanumeric-characters-and-ignoring-cases\">3. Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: \"A man, a plan, a canal: Panama\"  Output: true- Input: \"race a car\"  Output: false</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use two pointers approach that have one point to the start of the string and  the other point at the end.- Move them toward each other and compare if they're the same characters while  skipping non-alphanumeric characters and ignoring cases.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/leetcode/valid_palindrome_test.go\">Link to solution →</a></p><h3 id=\"4-implement-strstr-that-finds-the-first-occurrence-of-the-substring-needle-in-the-string-haystack-it-returns--1-if-needle-is-not-part-of-the-haystack\">4. Implement strstr() that finds the first occurrence of the substring needle in the string haystack. It returns -1 if needle is not part of the haystack.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: haystack = \"aaabacd\", needle = \"ba\"  Output: 3, because needle \"ba\" starts at index 3 in the haystack.</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Scan the needle with the haystack from its first position and start matching  all subsequent letters one by one.- If one letter does not match, start again with the next position in the  haystack.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(nm) time, O(1) space, where n is the length of haystack while m is the  length of needle.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/leetcode/strstr_test.go\">Link to solution →</a></p><h3 id=\"5-given-a-string-reverse-it-word-by-word\">5. Given a string, reverse it word by word.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: \"hard so be to have not does interview coding\"  Output: \"coding interview does not have to be so hard\"</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Approach with a two-pass solution.- The first pass is to split the string into an array of words separated by  spaces.- The second pass is to reverse the order of words in the array by using  two-pointer approach: swap two values on both ends as we move toward the  middle.- Concatenate the values of ordered array to create a final string.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(n) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/leetcode/reverse_words_string_test.go\">Link to solution →</a></p><h3 id=\"6-given-a-string-find-the-length-of-the-longest-substring-without-repeating-characters\">6. Given a string, find the length of the longest substring without repeating characters.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: \"abcabcbb\"  Output: 3  Explanation: The longest substring is \"abc\" with the length of 3.- Input: \"bbbbb\"  Output: 1  Explanation: The longest substring is \"b\" with the length of 1.</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Iterate through the string and keep track of the maximum length of non-repeating  characters using a hashmap that maps characters to their indices.- Could skip characters immediately if we found a repeating character.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(m) cost where m &lt; n and  n is the length of the string.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/leetcode/longest_substring_test.go\">Link to solution →</a></p><h3 id=\"7-given-a-sorted-integer-array-where-the-range-of-elements-are-0-99-inclusive-return-its-missing-ranges\">7. Given a sorted integer array where the range of elements are [0, 99] inclusive, return its missing ranges.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: []int{0, 1, 6, 16, 66, 99}  Output: []string{\"2-5\", \"7-15\", \"17-65\", \"67-98\"}- Input: []int{6, 16, 66}  Output: []string{\"0-5\", \"7-15\", \"17-65\", \"67-99\"}</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Keep two pointers where one is ahead of the other by 1 index.- Iterate through the list, calculate the difference of two consecutive numbers  in the list at each step and append it to a new list.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(m) space, where m &lt; n and n is the size of the input.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/leetcode/missing_ranges_test.go\">Link to solution →</a></p><h3 id=\"8-given-two-strings-determine-if-they-are-both-one-edit-distance-apart\">8. Given two strings, determine if they are both one edit distance apart.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: \"abcde\", \"abXde\"  Output: true  Explanation: Only \"c\" in S is replaced by \"X\" in T.- Input: \"abcde\", \"abcXde\"  Output: true  Explanation: \"X\" is inserted between \"c\" and \"d\" in S to get T.</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use two-pointer approach to traverse both strings at the same time and  keep track of count of difference characters.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/leetcode/one_edit_distance_test.go\">Link to solution →</a></p><blockquote>  <p>For more coding problems, please visit  <a href=\"https://github.com/hoanhan101/algo\">https://github.com/hoanhan101/algo</a>.</p></blockquote><blockquote>  <p>If you’re interested in getting updates for such content like these, consider  joining my <a href=\"https://tinyletter.com/hoanhan\">mail list here →</a></p></blockquote>",
            "url": "/2019/10/08/leetcode-array-string",
            
            
            
            "tags": ["leetcode","algorithm"],
            
            "date_published": "2019-10-08T00:00:00-04:00",
            "date_modified": "2019-10-08T00:00:00-04:00",
            
                "author":  {
                "name": "Hoanh An",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "/2019/10/01/interviewcake-linked-list",
            "title": "Interview Cake's Linked Lists",
            "summary": null,
            "content_text": "1. Delete a node from a singly-linked list, given only a pointer to that node.Approach:- Since we don't have access to the previous node, simply copy the value and  pointer of the next node and copy them into the current node.Cost:- O(1) time and O(1) space.Link to solution →2. Determine if a singly-linked list has a cycle.Approach:- Keep two pointers starting at the first node such that: every time one moves  one node ahead, the other moves 2 nodes ahead.- If the linked list has a cycle, the faster one will catch up with the slow  one. Otherwise, the faster one will each the end.Cost:- O(n) time and O(1) space.Link to solution →3. Reverse a linked list in-place.Approach:- Iterate through the list and point each node's next pointer to the previous item.Cost:- O(n) time, O(1) space.Link to solution →4. Find the kth to last node in a linked list.Example:- Input: list = 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, k = 2  Output: 5, because 5 is the 2nd to the last node (6)Approach:- Use two pointers such that one starts at the beginning and the other one  starts at k distance apart.- Walk both at the same speed toward the end.- When one hits the tail, the other one is on the target node.Cost:- O(n) time, O(1) space.Link to solution →  For more coding problems, please visit  https://github.com/hoanhan101/algo.  If you’re interested in getting updates for such content like these, consider  joining my mail list here →",
            "content_html": "<h3 id=\"1-delete-a-node-from-a-singly-linked-list-given-only-a-pointer-to-that-node\">1. Delete a node from a singly-linked list, given only a pointer to that node.</h3><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Since we don't have access to the previous node, simply copy the value and  pointer of the next node and copy them into the current node.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(1) time and O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/delete_node_test.go\">Link to solution →</a></p><h3 id=\"2-determine-if-a-singly-linked-list-has-a-cycle\">2. Determine if a singly-linked list has a cycle.</h3><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Keep two pointers starting at the first node such that: every time one moves  one node ahead, the other moves 2 nodes ahead.- If the linked list has a cycle, the faster one will catch up with the slow  one. Otherwise, the faster one will each the end.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time and O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/linked_list_cycle_test.go\">Link to solution →</a></p><h3 id=\"3-reverse-a-linked-list-in-place\">3. Reverse a linked list in-place.</h3><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Iterate through the list and point each node's next pointer to the previous item.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/reverse_linked_list_test.go\">Link to solution →</a></p><h3 id=\"4-find-the-kth-to-last-node-in-a-linked-list\">4. Find the kth to last node in a linked list.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: list = 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6, k = 2  Output: 5, because 5 is the 2nd to the last node (6)</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use two pointers such that one starts at the beginning and the other one  starts at k distance apart.- Walk both at the same speed toward the end.- When one hits the tail, the other one is on the target node.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/kth_to_last_test.go\">Link to solution →</a></p><blockquote>  <p>For more coding problems, please visit  <a href=\"https://github.com/hoanhan101/algo\">https://github.com/hoanhan101/algo</a>.</p></blockquote><blockquote>  <p>If you’re interested in getting updates for such content like these, consider  joining my <a href=\"https://tinyletter.com/hoanhan\">mail list here →</a></p></blockquote>",
            "url": "/2019/10/01/interviewcake-linked-list",
            
            
            
            "tags": ["interviewcake","algorithm"],
            
            "date_published": "2019-10-01T00:00:00-04:00",
            "date_modified": "2019-10-01T00:00:00-04:00",
            
                "author":  {
                "name": "Hoanh An",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "/2019/09/24/7-sorting-algorithms",
            "title": "7 sorting algorithms",
            "summary": null,
            "content_text": "Here are 7 sorting algorithms implementations in Go that we are going to cover in this post:  Bubble Sort  Selection Sort  Insertion Sort  Merge Sort  Quicksort  Heapsort  Counting SortBubble SortApproach:Repeatedly swap the adjacent elements if they are in the wrong order in thearray, one item at a time.Cost:O(n^2) time and O(1) space.Solution:func bubbleSort(in []int) {\tlength := len(in)\t// for each element in the list, check it with almost every other element.\tfor i := 0; i &lt; length; i++ {\t\t// since the last i element is already in place, only iterate through\t\t// the item before the last one.\t\tfor j := 0; j &lt; length-i-1; j++ {\t\t\t// swap the adjacent elements if they are not in ascending order.\t\t\tif in[j] &gt; in[j+1] {\t\t\t\tcommon.Swap(in, j, j+1)\t\t\t}\t\t}\t}}Selection SortApproach:Repeatedly select the next smallest element from the unsorted array and move itto the front.Cost:O(n^2) time and O(1) space.Solution:func selectionSort(in []int) {\tminIndex := 0\tfor i := 0; i &lt; len(in)-1; i++ {\t\tminIndex = i\t\t// find the minimum in the rest of the array.\t\tfor j := i + 1; j &lt; len(in); j++ {\t\t\tif in[j] &lt; in[minIndex] {\t\t\t\tminIndex = j\t\t\t}\t\t}\t\t// swap the minimum value with the first value.\t\tcommon.Swap(in, i, minIndex)\t}}Insertion SortApproach:Insert elements from an unsorted array into a sorted subsection of thearray, one item at a time.Cost:O(n^2) time and O(1) space.Solution:func insertionSort(in []int) {\t// iterate through the list from position 1.\tfor i := 1; i &lt; len(in); i++ {\t\t// shift each one to the left by swapping it with the one before until\t\t// it's in the right spot.\t\tcurrent := in[i]\t\tj := i - 1\t\tfor j &gt;= 0 &amp;&amp; current &lt; in[j] {\t\t\tin[j+1] = in[j]\t\t\tj--\t\t}\t\tin[j+1] = current\t}}Merge SortApproach:Split the input in half, recursively sorts each half, then merge thesorted halves back together.Cost:O(nlogn) time and O(n) space.Solution:func mergeSort(in []int) []int {\t// base case\tif len(in) &lt;= 1 {\t\treturn in\t}\t// split the input in half.\tmiddleIndex := len(in) / 2\tleft := in[:middleIndex]\tright := in[middleIndex:]\t// sort each half.\tleftSorted := mergeSort(left)\trightSorted := mergeSort(right)\t// merge the sorted halves.\treturn mergeSortedArray(leftSorted, rightSorted)}func mergeSortedArray(a1, a2 []int) []int {\tout := []int{}\t// keep two \"pointer\" at index 0 and move up accordingly as one get\t// merged in.\ti, j := 0, 0\tfor i &lt; len(a1) &amp;&amp; j &lt; len(a2) {\t\tif a1[i] &lt; a2[j] {\t\t\tout = append(out, a1[i])\t\t\ti++\t\t} else {\t\t\tout = append(out, a2[j])\t\t\tj++\t\t}\t}\t// if we get here, one array must have bigger size than the other. could\t// figure out which one is it then copy the rest of its to our final one.\tif i &lt; len(a1) {\t\tout = append(out, a1[i:]...)\t}\tif j &lt; len(a2) {\t\tout = append(out, a2[j:]...)\t}\treturn out}QuicksortApproach:Recursively divide the input into two smaller arrays around a pivot, whereone half has items smaller than the pivot, other half has items bigger thanthe pivot.Cost:O(nlogn) time and O(nlogn) space.Solution:func quicksort(in []int, start, end int) {\tif start &lt; end {\t\t// pi is the pivot/partition index.\t\tpi := partition(in, start, end)\t\t// sort the items before and after partition.\t\tquicksort(in, start, pi-1)\t\tquicksort(in, pi+1, end)\t}}func partition(in []int, start, end int) int {\tpivot := in[end]\tleft := start\tright := end - 1\tfor left &lt;= right {\t\t// keep going until we find something on the left that belongs to the\t\t// right.\t\tfor left &lt;= end &amp;&amp; in[left] &lt; pivot {\t\t\tleft++\t\t}\t\t// keep going until we find something on the right that belongs to the\t\t// left.\t\tfor right &gt;= start &amp;&amp; in[right] &gt;= pivot {\t\t\tright--\t\t}\t\t// by swapping the item at left and right index, we move the item that\t\t// is smaller than the pivot to the left half and vice versa.\t\tif left &lt; right {\t\t\tcommon.Swap(in, left, right)\t\t} else {\t\t\t// once the partition is finished, move the pivot back to its final\t\t\t// position by swapping the item at left and end index.\t\t\tcommon.Swap(in, left, end)\t\t}\t}\treturn left}HeapsortApproach:Similar to selection sort, repeatedly choose the largest item and move it tothe end of the array using a max heap.Cost:O(nlogn) time and O(1) space.Solution:func heapsort(in []int) {\theapify(in)\tsize := len(in)\tfor size &gt; 0 {\t\t// repeatedly remove the largest item.\t\tlargest := removeLargest(in, size)\t\t// update the heap size.\t\tsize--\t\t// store the removed value at the end of the list.\t\tin[size] = largest\t}}// heapify transform the input into a max heap.func heapify(in []int) {\tfor i := len(in) - 1; i &gt; -1; i-- {\t\tbubbleDown(in, len(in), i)\t}}// bubbleDown allow larger values to reach the top.func bubbleDown(heap []int, heapSize int, index int) {\tfor index &lt; heapSize {\t\t// fast-calculate the children left and right index.\t\tleft := index*2 + 1\t\tright := index*2 + 2\t\t// stop if there is no child node.\t\tif left &gt;= heapSize {\t\t\tbreak\t\t}\t\t// find the larger index\t\tlarger := left\t\tif right &lt; heapSize &amp;&amp; heap[left] &lt; heap[right] {\t\t\tlarger = right\t\t}\t\t// if the current item is larger than both children, we're done.\t\t// if not, swap with the larger child.\t\tif heap[index] &lt; heap[larger] {\t\t\tcommon.Swap(heap, index, larger)\t\t} else {\t\t\tbreak\t\t}\t}}// removeLargest remove and return the largest item from the heap.func removeLargest(heap []int, heapSize int) int {\t// largest item is at the top of our max heap.\tlargest := heap[0]\t// move the last item into the root position.\theap[0] = heap[heapSize-1]\t// bubble down from the root to restore the heap.\tbubbleDown(heap, heapSize-1, 0)\treturn largest}Counting SortApproach:Iterate through the input, count the number of times each item occurs, usethese counts to compute each item's index in the final sorted array.Cost:O(n) time and O(n) space.Solution:func countingSort(in []int, max int) []int {\t// utilize max value to create a fix-sized list of item counts.\tcounts := make([]int, max+1)\tout := make([]int, 0)\t// populate the array where its indices represent items themselves and\t// its values represent how many time the item appears.\tfor _, item := range in {\t\tcounts[item]++\t}\t// iterate through the counts and add the item to the output list.\tfor i := 0; i &lt; len(counts); i++ {\t\tcount := counts[i]\t\tfor j := 0; j &lt; count; j++ {\t\t\tout = append(out, i)\t\t}\t}\treturn out}  For more coding problems, please visit  https://github.com/hoanhan101/algo.  If you’re interested in getting updates for such content like these, consider  joining my mail list here →",
            "content_html": "<p>Here are 7 sorting algorithms implementations in Go that we are going to cover in this post:</p><ol>  <li>Bubble Sort</li>  <li>Selection Sort</li>  <li>Insertion Sort</li>  <li>Merge Sort</li>  <li>Quicksort</li>  <li>Heapsort</li>  <li>Counting Sort</li></ol><h2 id=\"bubble-sort\">Bubble Sort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Repeatedly swap the adjacent elements if they are in the wrong order in thearray, one item at a time.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(n^2) time and O(1) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">bubbleSort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"n\">length</span> <span class=\"o\">:=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span>\t<span class=\"c\">// for each element in the list, check it with almost every other element.</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// since the last i element is already in place, only iterate through</span>\t\t<span class=\"c\">// the item before the last one.</span>\t\t<span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span><span class=\"o\">-</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t\t<span class=\"c\">// swap the adjacent elements if they are not in ascending order.</span>\t\t\t<span class=\"k\">if</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t\t<span class=\"n\">common</span><span class=\"o\">.</span><span class=\"n\">Swap</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">)</span>\t\t\t<span class=\"p\">}</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"selection-sort\">Selection Sort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Repeatedly select the next smallest element from the unsorted array and move itto the front.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(n^2) time and O(1) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">selectionSort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"n\">minIndex</span> <span class=\"o\">:=</span> <span class=\"m\">0</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t<span class=\"n\">minIndex</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\t\t<span class=\"c\">// find the minimum in the rest of the array.</span>\t\t<span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">);</span> <span class=\"n\">j</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t\t<span class=\"k\">if</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">minIndex</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t\t<span class=\"n\">minIndex</span> <span class=\"o\">=</span> <span class=\"n\">j</span>\t\t\t<span class=\"p\">}</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"c\">// swap the minimum value with the first value.</span>\t\t<span class=\"n\">common</span><span class=\"o\">.</span><span class=\"n\">Swap</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">minIndex</span><span class=\"p\">)</span>\t<span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"insertion-sort\">Insertion Sort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Insert elements from an unsorted array into a sorted subsection of thearray, one item at a time.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(n^2) time and O(1) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">insertionSort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"c\">// iterate through the list from position 1.</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">);</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// shift each one to the left by swapping it with the one before until</span>\t\t<span class=\"c\">// it's in the right spot.</span>\t\t<span class=\"n\">current</span> <span class=\"o\">:=</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\t\t<span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"m\">1</span>\t\t<span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">&gt;=</span> <span class=\"m\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">current</span> <span class=\"o\">&lt;</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span>\t\t\t<span class=\"n\">j</span><span class=\"o\">--</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">current</span>\t<span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"merge-sort\">Merge Sort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Split the input in half, recursively sorts each half, then merge thesorted halves back together.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(nlogn) time and O(n) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">mergeSort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">[]</span><span class=\"kt\">int</span> <span class=\"p\">{</span>\t<span class=\"c\">// base case</span>\t<span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span> <span class=\"o\">&lt;=</span> <span class=\"m\">1</span> <span class=\"p\">{</span>\t\t<span class=\"k\">return</span> <span class=\"n\">in</span>\t<span class=\"p\">}</span>\t<span class=\"c\">// split the input in half.</span>\t<span class=\"n\">middleIndex</span> <span class=\"o\">:=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"m\">2</span>\t<span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"o\">:</span><span class=\"n\">middleIndex</span><span class=\"p\">]</span>\t<span class=\"n\">right</span> <span class=\"o\">:=</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">middleIndex</span><span class=\"o\">:</span><span class=\"p\">]</span>\t<span class=\"c\">// sort each half.</span>\t<span class=\"n\">leftSorted</span> <span class=\"o\">:=</span> <span class=\"n\">mergeSort</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">)</span>\t<span class=\"n\">rightSorted</span> <span class=\"o\">:=</span> <span class=\"n\">mergeSort</span><span class=\"p\">(</span><span class=\"n\">right</span><span class=\"p\">)</span>\t<span class=\"c\">// merge the sorted halves.</span>\t<span class=\"k\">return</span> <span class=\"n\">mergeSortedArray</span><span class=\"p\">(</span><span class=\"n\">leftSorted</span><span class=\"p\">,</span> <span class=\"n\">rightSorted</span><span class=\"p\">)</span><span class=\"p\">}</span><span class=\"k\">func</span> <span class=\"n\">mergeSortedArray</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a2</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">[]</span><span class=\"kt\">int</span> <span class=\"p\">{</span>\t<span class=\"n\">out</span> <span class=\"o\">:=</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">{}</span>\t<span class=\"c\">// keep two \"pointer\" at index 0 and move up accordingly as one get</span>\t<span class=\"c\">// merged in.</span>\t<span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">,</span> <span class=\"m\">0</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">a2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t\t<span class=\"k\">if</span> <span class=\"n\">a1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"nb\">append</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\t\t\t<span class=\"n\">i</span><span class=\"o\">++</span>\t\t<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"nb\">append</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">])</span>\t\t\t<span class=\"n\">j</span><span class=\"o\">++</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span>\t<span class=\"c\">// if we get here, one array must have bigger size than the other. could</span>\t<span class=\"c\">// figure out which one is it then copy the rest of its to our final one.</span>\t<span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t\t<span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"nb\">append</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"p\">]</span><span class=\"o\">...</span><span class=\"p\">)</span>\t<span class=\"p\">}</span>\t<span class=\"k\">if</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">a2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t\t<span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"nb\">append</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">:</span><span class=\"p\">]</span><span class=\"o\">...</span><span class=\"p\">)</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"n\">out</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"quicksort\">Quicksort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Recursively divide the input into two smaller arrays around a pivot, whereone half has items smaller than the pivot, other half has items bigger thanthe pivot.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(nlogn) time and O(nlogn) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">quicksort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"k\">if</span> <span class=\"n\">start</span> <span class=\"o\">&lt;</span> <span class=\"n\">end</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// pi is the pivot/partition index.</span>\t\t<span class=\"n\">pi</span> <span class=\"o\">:=</span> <span class=\"n\">partition</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">)</span>\t\t<span class=\"c\">// sort the items before and after partition.</span>\t\t<span class=\"n\">quicksort</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">pi</span><span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">)</span>\t\t<span class=\"n\">quicksort</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">pi</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">)</span>\t<span class=\"p\">}</span><span class=\"p\">}</span><span class=\"k\">func</span> <span class=\"n\">partition</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"kt\">int</span> <span class=\"p\">{</span>\t<span class=\"n\">pivot</span> <span class=\"o\">:=</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">end</span><span class=\"p\">]</span>\t<span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"n\">start</span>\t<span class=\"n\">right</span> <span class=\"o\">:=</span> <span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"m\">1</span>\t<span class=\"k\">for</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// keep going until we find something on the left that belongs to the</span>\t\t<span class=\"c\">// right.</span>\t\t<span class=\"k\">for</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">end</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">left</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">pivot</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">left</span><span class=\"o\">++</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"c\">// keep going until we find something on the right that belongs to the</span>\t\t<span class=\"c\">// left.</span>\t\t<span class=\"k\">for</span> <span class=\"n\">right</span> <span class=\"o\">&gt;=</span> <span class=\"n\">start</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">right</span><span class=\"p\">]</span> <span class=\"o\">&gt;=</span> <span class=\"n\">pivot</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">right</span><span class=\"o\">--</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"c\">// by swapping the item at left and right index, we move the item that</span>\t\t<span class=\"c\">// is smaller than the pivot to the left half and vice versa.</span>\t\t<span class=\"k\">if</span> <span class=\"n\">left</span> <span class=\"o\">&lt;</span> <span class=\"n\">right</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">common</span><span class=\"o\">.</span><span class=\"n\">Swap</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">)</span>\t\t<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\t\t\t<span class=\"c\">// once the partition is finished, move the pivot back to its final</span>\t\t\t<span class=\"c\">// position by swapping the item at left and end index.</span>\t\t\t<span class=\"n\">common</span><span class=\"o\">.</span><span class=\"n\">Swap</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">)</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"n\">left</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"heapsort\">Heapsort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Similar to selection sort, repeatedly choose the largest item and move it tothe end of the array using a max heap.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(nlogn) time and O(1) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">heapsort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"n\">heapify</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span>\t<span class=\"n\">size</span> <span class=\"o\">:=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span>\t<span class=\"k\">for</span> <span class=\"n\">size</span> <span class=\"o\">&gt;</span> <span class=\"m\">0</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// repeatedly remove the largest item.</span>\t\t<span class=\"n\">largest</span> <span class=\"o\">:=</span> <span class=\"n\">removeLargest</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"p\">)</span>\t\t<span class=\"c\">// update the heap size.</span>\t\t<span class=\"n\">size</span><span class=\"o\">--</span>\t\t<span class=\"c\">// store the removed value at the end of the list.</span>\t\t<span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">size</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">largest</span>\t<span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c\">// heapify transform the input into a max heap.</span><span class=\"k\">func</span> <span class=\"n\">heapify</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">--</span> <span class=\"p\">{</span>\t\t<span class=\"n\">bubbleDown</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">),</span> <span class=\"n\">i</span><span class=\"p\">)</span>\t<span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c\">// bubbleDown allow larger values to reach the top.</span><span class=\"k\">func</span> <span class=\"n\">bubbleDown</span><span class=\"p\">(</span><span class=\"n\">heap</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">heapSize</span> <span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">index</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"k\">for</span> <span class=\"n\">index</span> <span class=\"o\">&lt;</span> <span class=\"n\">heapSize</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// fast-calculate the children left and right index.</span>\t\t<span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"n\">index</span><span class=\"o\">*</span><span class=\"m\">2</span> <span class=\"o\">+</span> <span class=\"m\">1</span>\t\t<span class=\"n\">right</span> <span class=\"o\">:=</span> <span class=\"n\">index</span><span class=\"o\">*</span><span class=\"m\">2</span> <span class=\"o\">+</span> <span class=\"m\">2</span>\t\t<span class=\"c\">// stop if there is no child node.</span>\t\t<span class=\"k\">if</span> <span class=\"n\">left</span> <span class=\"o\">&gt;=</span> <span class=\"n\">heapSize</span> <span class=\"p\">{</span>\t\t\t<span class=\"k\">break</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"c\">// find the larger index</span>\t\t<span class=\"n\">larger</span> <span class=\"o\">:=</span> <span class=\"n\">left</span>\t\t<span class=\"k\">if</span> <span class=\"n\">right</span> <span class=\"o\">&lt;</span> <span class=\"n\">heapSize</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"n\">left</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"n\">right</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">larger</span> <span class=\"o\">=</span> <span class=\"n\">right</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"c\">// if the current item is larger than both children, we're done.</span>\t\t<span class=\"c\">// if not, swap with the larger child.</span>\t\t<span class=\"k\">if</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"n\">larger</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">common</span><span class=\"o\">.</span><span class=\"n\">Swap</span><span class=\"p\">(</span><span class=\"n\">heap</span><span class=\"p\">,</span> <span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">larger</span><span class=\"p\">)</span>\t\t<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\t\t\t<span class=\"k\">break</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c\">// removeLargest remove and return the largest item from the heap.</span><span class=\"k\">func</span> <span class=\"n\">removeLargest</span><span class=\"p\">(</span><span class=\"n\">heap</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">heapSize</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"kt\">int</span> <span class=\"p\">{</span>\t<span class=\"c\">// largest item is at the top of our max heap.</span>\t<span class=\"n\">largest</span> <span class=\"o\">:=</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"p\">]</span>\t<span class=\"c\">// move the last item into the root position.</span>\t<span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"n\">heapSize</span><span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">]</span>\t<span class=\"c\">// bubble down from the root to restore the heap.</span>\t<span class=\"n\">bubbleDown</span><span class=\"p\">(</span><span class=\"n\">heap</span><span class=\"p\">,</span> <span class=\"n\">heapSize</span><span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">,</span> <span class=\"m\">0</span><span class=\"p\">)</span>\t<span class=\"k\">return</span> <span class=\"n\">largest</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"counting-sort\">Counting Sort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Iterate through the input, count the number of times each item occurs, usethese counts to compute each item's index in the final sorted array.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(n) time and O(n) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">countingSort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">max</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">[]</span><span class=\"kt\">int</span> <span class=\"p\">{</span>\t<span class=\"c\">// utilize max value to create a fix-sized list of item counts.</span>\t<span class=\"n\">counts</span> <span class=\"o\">:=</span> <span class=\"nb\">make</span><span class=\"p\">([]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">max</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">)</span>\t<span class=\"n\">out</span> <span class=\"o\">:=</span> <span class=\"nb\">make</span><span class=\"p\">([]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"m\">0</span><span class=\"p\">)</span>\t<span class=\"c\">// populate the array where its indices represent items themselves and</span>\t<span class=\"c\">// its values represent how many time the item appears.</span>\t<span class=\"k\">for</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">item</span> <span class=\"o\">:=</span> <span class=\"k\">range</span> <span class=\"n\">in</span> <span class=\"p\">{</span>\t\t<span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">item</span><span class=\"p\">]</span><span class=\"o\">++</span>\t<span class=\"p\">}</span>\t<span class=\"c\">// iterate through the counts and add the item to the output list.</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">counts</span><span class=\"p\">);</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t<span class=\"n\">count</span> <span class=\"o\">:=</span> <span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\t\t<span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">count</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"nb\">append</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">)</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"n\">out</span><span class=\"p\">}</span></code></pre></div></div><blockquote>  <p>For more coding problems, please visit  <a href=\"https://github.com/hoanhan101/algo\">https://github.com/hoanhan101/algo</a>.</p></blockquote><blockquote>  <p>If you’re interested in getting updates for such content like these, consider  joining my <a href=\"https://tinyletter.com/hoanhan\">mail list here →</a></p></blockquote>",
            "url": "/2019/09/24/7-sorting-algorithms",
            
            
            
            "tags": ["algorithm","sorting"],
            
            "date_published": "2019-09-24T00:00:00-04:00",
            "date_modified": "2019-09-24T00:00:00-04:00",
            
                "author":  {
                "name": "Hoanh An",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "/2019/09/17/interviewcake-queue-stack",
            "title": "Interview Cake's Queues and Stacks",
            "summary": null,
            "content_text": "1. Implement a stack with a method getMax() that returns the largest element in the stack in O(1) time.Approach:- We use two stack implementation themselves: one holds all the items and the  other holds all the maximum values after each push() and pop().- That way, we could keep track of your maximum value up to date in constant  time.Cost:- O(1) time, O(m) space where m is the number of operations performed on the  stack.Link to solution →2. Implement a queue with 2 stacks.Approach:- Use one stack for enqueuing item and the other to reverse the order them for  dequeuing/popping item.Cost:- O(1) time, O(m) space m is the number of operations.Link to solution →3. Given a sentence as string, and the position of an opening parenthesis position, find the matching closing one position.Example:- Input: \"I ((like) (nesting) parenthesis)\", opening parenthesis position = 2  Output: 31, because the matching parenthesis of the one in position 2 is at  index 31.Approach:- Iterate through the string and keep a count of matching parenthesis at each  step.Cost:- O(n) time, O(1) space.Link to solution →4. Given a string, determine if its brackets are properly nested.Example:- Input: \"{[]()}\"  Output: true- Input: \"{[(])}\"  Output: false- Input: \"{[}\"  Output: falseApproach:- Use a stack to keep track of matching parenthesis as we iterate  through the string.Cost:- O(n) time and O(n) space, where n is the number of operations.Link to solution →  For more coding problems, please visit  https://github.com/hoanhan101/algo.  If you’re interested in getting updates for such content like these, consider  joining my mail list here →",
            "content_html": "<h3 id=\"1-implement-a-stack-with-a-method-getmax-that-returns-the-largest-element-in-the-stack-in-o1-time\">1. Implement a stack with a method getMax() that returns the largest element in the stack in O(1) time.</h3><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- We use two stack implementation themselves: one holds all the items and the  other holds all the maximum values after each push() and pop().- That way, we could keep track of your maximum value up to date in constant  time.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(1) time, O(m) space where m is the number of operations performed on the  stack.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/largest_stack_test.go\">Link to solution →</a></p><h3 id=\"2-implement-a-queue-with-2-stacks\">2. Implement a queue with 2 stacks.</h3><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use one stack for enqueuing item and the other to reverse the order them for  dequeuing/popping item.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(1) time, O(m) space m is the number of operations.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/queue_two_stacks_test.go\">Link to solution →</a></p><h3 id=\"3-given-a-sentence-as-string-and-the-position-of-an-opening-parenthesis-position-find-the-matching-closing-one-position\">3. Given a sentence as string, and the position of an opening parenthesis position, find the matching closing one position.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: \"I ((like) (nesting) parenthesis)\", opening parenthesis position = 2  Output: 31, because the matching parenthesis of the one in position 2 is at  index 31.</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Iterate through the string and keep a count of matching parenthesis at each  step.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/parenthesis_matching_test.go\">Link to solution →</a></p><h3 id=\"4-given-a-string-determine-if-its-brackets-are-properly-nested\">4. Given a string, determine if its brackets are properly nested.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: \"{[]()}\"  Output: true- Input: \"{[(])}\"  Output: false- Input: \"{[}\"  Output: false</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use a stack to keep track of matching parenthesis as we iterate  through the string.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time and O(n) space, where n is the number of operations.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/bracket_validator_test.go\">Link to solution →</a></p><blockquote>  <p>For more coding problems, please visit  <a href=\"https://github.com/hoanhan101/algo\">https://github.com/hoanhan101/algo</a>.</p></blockquote><blockquote>  <p>If you’re interested in getting updates for such content like these, consider  joining my <a href=\"https://tinyletter.com/hoanhan\">mail list here →</a></p></blockquote>",
            "url": "/2019/09/17/interviewcake-queue-stack",
            
            
            
            "tags": ["interviewcake","algorithm"],
            
            "date_published": "2019-09-17T00:00:00-04:00",
            "date_modified": "2019-09-17T00:00:00-04:00",
            
                "author":  {
                "name": "Hoanh An",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "/2019/08/31/interviewcake-tree-graph",
            "title": "Interview Cake's Trees and Graphs",
            "summary": null,
            "content_text": "1. Given a binary tree, determine if it is “superbalanced” - the difference between the depths of any two leaf nodes is no greater than 1.Example:- Input:         1      2     3    4   5      7          6  8   9                   10  Output: false  Even though this tree is balanced by definition, it is not \"superbalanced\".Approach:- Use a depth-first walk through the tree and keep track of the depth as we  go.- Every time we found a leaf with a new depth, there are two ways that the  tree could be unbalanced:   - There are more than 2 different leaf depths.   - There are exactly 2 depths but they are more than 1 apart.Cost:- O(n) time, O(n) space.- The worst case is that we have to iterate all nodes in the tree so the time  complexity is O(n). For space complexity, we have to keep track of the all  the nodes at every depth. Hence, it is O(n).Link to solution →2. Given a binary tree, determine if it is a binary search tree.Example:- Input:          5      3       8    2   4   7   9  1               11  Output: true, because for each node, its value is greater than all values in  the left subtree and less than all values in the right one.Approach:- Use a depth-first walk through the tree and validate each node as we go.- If a node appears in the left subtree, it must be less than its ancestor and  vice versa.- Instead of keeping track of every ancestor to check the inequalities, just  need to check the largest number it must be greater than and the smallest one  it must be less than, aka lower bound and upper bound.Cost:- O(n) time, O(n) space.- The worst case is that we have to iterate all nodes in the tree so the time  complexity is O(n). For space complexity, we have to keep track of the lower  bound and upper bound as we traverse the tree via a stack. Hence, the worst  case is O(n).Link to solution →3. Given a binary search tree, find the 2nd largest item.Example:- Input:          5      3       8    2   4   7   9  1               11  Output: 9- Input:           5      3        8    2   4   7     16                11              9   12  Output: 12Approach:- The largest item in a binary search tree is the rightmost item. Can  simply traverse down the tree recursively to find one.- The 2nd largest item could be the parent of the largest but it's not  necessary since the largest could have a left subtree and there might exist  one there.- Still, the second largest one when the largest has a left subtree is basically  the largest one in that left subtree.Cost:- O(h) time, O(1) space, where h is the height of the tree.- If the tree is balanced, the time complexity is (Olgn). Otherwise, it's O(n).Link to solution →4. Given an undirected graph, with maximum degree d, find a graph coloring using at most d + 1 colors. Assume that there is no node with a loop.Example:- For a graph with degree 3, we could use at most 4 colors.Approach:- Use a greedy approach to iterate over the graph and assign each node the  first non-taken color that we found.Cost:- O(m) time and O(d) space, where m is sum of all the nodes and edges, d is  the number of all colors.- Even though it seems like we have an outer and inner loop, we carefully walk  through the graph one node at a time and stop checking for colors as soon as  we found one that is non-taken.- About the space complexity, it makes sense that we have to store all  available colors in the worst case. Hence it takes up O(d) space.Link to solution →  For more coding problems, please visit  https://github.com/hoanhan101/algo.  If you’re interested in getting updates for such content like these, consider  joining my mail list here →",
            "content_html": "<h3 id=\"1-given-a-binary-tree-determine-if-it-is-superbalanced---the-difference-between-the-depths-of-any-two-leaf-nodes-is-no-greater-than-1\">1. Given a binary tree, determine if it is “superbalanced” - the difference between the depths of any two leaf nodes is no greater than 1.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input:         1      2     3    4   5      7          6  8   9                   10  Output: false  Even though this tree is balanced by definition, it is not \"superbalanced\".</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use a depth-first walk through the tree and keep track of the depth as we  go.- Every time we found a leaf with a new depth, there are two ways that the  tree could be unbalanced:   - There are more than 2 different leaf depths.   - There are exactly 2 depths but they are more than 1 apart.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(n) space.- The worst case is that we have to iterate all nodes in the tree so the time  complexity is O(n). For space complexity, we have to keep track of the all  the nodes at every depth. Hence, it is O(n).</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/balanced_binary_tree_test.go\">Link to solution →</a></p><h3 id=\"2-given-a-binary-tree-determine-if-it-is-a-binary-search-tree\">2. Given a binary tree, determine if it is a binary search tree.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input:          5      3       8    2   4   7   9  1               11  Output: true, because for each node, its value is greater than all values in  the left subtree and less than all values in the right one.</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use a depth-first walk through the tree and validate each node as we go.- If a node appears in the left subtree, it must be less than its ancestor and  vice versa.- Instead of keeping track of every ancestor to check the inequalities, just  need to check the largest number it must be greater than and the smallest one  it must be less than, aka lower bound and upper bound.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(n) space.- The worst case is that we have to iterate all nodes in the tree so the time  complexity is O(n). For space complexity, we have to keep track of the lower  bound and upper bound as we traverse the tree via a stack. Hence, the worst  case is O(n).</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/binary_search_tree_test.go\">Link to solution →</a></p><h3 id=\"3-given-a-binary-search-tree-find-the-2nd-largest-item\">3. Given a binary search tree, find the 2nd largest item.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input:          5      3       8    2   4   7   9  1               11  Output: 9- Input:           5      3        8    2   4   7     16                11              9   12  Output: 12</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- The largest item in a binary search tree is the rightmost item. Can  simply traverse down the tree recursively to find one.- The 2nd largest item could be the parent of the largest but it's not  necessary since the largest could have a left subtree and there might exist  one there.- Still, the second largest one when the largest has a left subtree is basically  the largest one in that left subtree.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(h) time, O(1) space, where h is the height of the tree.- If the tree is balanced, the time complexity is (Olgn). Otherwise, it's O(n).</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/2nd_largest_item_bst_test.go\">Link to solution →</a></p><h3 id=\"4-given-an-undirected-graph-with-maximum-degree-d-find-a-graph-coloring-using-at-most-d--1-colors-assume-that-there-is-no-node-with-a-loop\">4. Given an undirected graph, with maximum degree d, find a graph coloring using at most d + 1 colors. Assume that there is no node with a loop.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- For a graph with degree 3, we could use at most 4 colors.</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use a greedy approach to iterate over the graph and assign each node the  first non-taken color that we found.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(m) time and O(d) space, where m is sum of all the nodes and edges, d is  the number of all colors.- Even though it seems like we have an outer and inner loop, we carefully walk  through the graph one node at a time and stop checking for colors as soon as  we found one that is non-taken.- About the space complexity, it makes sense that we have to store all  available colors in the worst case. Hence it takes up O(d) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/graph_coloring_test.go\">Link to solution →</a></p><blockquote>  <p>For more coding problems, please visit  <a href=\"https://github.com/hoanhan101/algo\">https://github.com/hoanhan101/algo</a>.</p></blockquote><blockquote>  <p>If you’re interested in getting updates for such content like these, consider  joining my <a href=\"https://tinyletter.com/hoanhan\">mail list here →</a></p></blockquote>",
            "url": "/2019/08/31/interviewcake-tree-graph",
            
            
            
            "tags": ["interviewcake","algorithm"],
            
            "date_published": "2019-08-31T00:00:00-04:00",
            "date_modified": "2019-08-31T00:00:00-04:00",
            
                "author":  {
                "name": "Hoanh An",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "/2019/08/24/interviewcake-greedy-algorithms",
            "title": "Interview Cake's Greedy algorithms",
            "summary": null,
            "content_text": "1. Given a list of stock prices (integer) in chronological order, return the max profit from buying at earlier time and selling at later time.Example:- Input: []int{10, 7, 5, 8, 11, 9}  Output: 6, because one can buy at 5 and sell at 11Approach:- Use a greedy approach to keep track of the minimum price and the maximum  profit for each value while iterating through the list.Cost:- O(n) time, O(1) space.Link to solution →2. Given a list of integers, return the highest product of three numbers.Example:- Input: []int{-10, -10, 1, 3, 2}  Output: 300, because -10.-10.3 gives the highest productApproach:- Use a greedy approach to keep track of the current highest, current lowest,  highest of three, highest of two and lowest of two for every value as we  iterate through the list.Cost:- O(n) time, O(1) space.Link to solution →3. Given a list of integers, return a corresponding list where every index holds the product of every other values except the value in that index. And, you can’t use division!Example:- Input: []int{1, 7, 3, 4}  Output: []int{84, 12, 28, 21}Approach:- Iterate through the list and at each step, calculate the product of all  the integers before each index and the product of all the integers after  each index.Cost:- O(n) time, O(n) space.Link to solution →4. Given a list of integers, shuffle its location in-place.Example:- Input: []int{1, 2, 3, 4, 5}  Output: []int{2, 1, 4, 3, 5}Approach:- Iterate through the list, swap current value with a value in a randomized  index that is between the current and last index.Cost:- O(n) time, O(1) space.Link to solution →  For more coding problems, please visit  https://github.com/hoanhan101/algo.  If you’re interested in getting updates for such content like these, consider  joining my mail list here →",
            "content_html": "<h3 id=\"1-given-a-list-of-stock-prices-integer-in-chronological-order-return-the-max-profit-from-buying-at-earlier-time-and-selling-at-later-time\">1. Given a list of stock prices (integer) in chronological order, return the max profit from buying at earlier time and selling at later time.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: []int{10, 7, 5, 8, 11, 9}  Output: 6, because one can buy at 5 and sell at 11</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use a greedy approach to keep track of the minimum price and the maximum  profit for each value while iterating through the list.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/apple_stocks_test.go\">Link to solution →</a></p><h3 id=\"2-given-a-list-of-integers-return-the-highest-product-of-three-numbers\">2. Given a list of integers, return the highest product of three numbers.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: []int{-10, -10, 1, 3, 2}  Output: 300, because -10.-10.3 gives the highest product</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use a greedy approach to keep track of the current highest, current lowest,  highest of three, highest of two and lowest of two for every value as we  iterate through the list.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/highest_product_of_three_test.go\">Link to solution →</a></p><h3 id=\"3-given-a-list-of-integers-return-a-corresponding-list-where-every-index-holds-the-product-of-every-other-values-except-the-value-in-that-index-and-you-cant-use-division\">3. Given a list of integers, return a corresponding list where every index holds the product of every other values except the value in that index. And, you can’t use division!</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: []int{1, 7, 3, 4}  Output: []int{84, 12, 28, 21}</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Iterate through the list and at each step, calculate the product of all  the integers before each index and the product of all the integers after  each index.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(n) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/product_of_others_test.go\">Link to solution →</a></p><h3 id=\"4-given-a-list-of-integers-shuffle-its-location-in-place\">4. Given a list of integers, shuffle its location in-place.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: []int{1, 2, 3, 4, 5}  Output: []int{2, 1, 4, 3, 5}</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Iterate through the list, swap current value with a value in a randomized  index that is between the current and last index.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/inplace_shuffle_test.go\">Link to solution →</a></p><blockquote>  <p>For more coding problems, please visit  <a href=\"https://github.com/hoanhan101/algo\">https://github.com/hoanhan101/algo</a>.</p></blockquote><blockquote>  <p>If you’re interested in getting updates for such content like these, consider  joining my <a href=\"https://tinyletter.com/hoanhan\">mail list here →</a></p></blockquote>",
            "url": "/2019/08/24/interviewcake-greedy-algorithms",
            
            
            
            "tags": ["interviewcake","algorithm"],
            
            "date_published": "2019-08-24T00:00:00-04:00",
            "date_modified": "2019-08-24T00:00:00-04:00",
            
                "author":  {
                "name": "Hoanh An",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "/2019/08/23/interview-cake-hashing-problems",
            "title": "Interview Cake's Hashing problems",
            "summary": null,
            "content_text": "1. Given a list of movie lengths and a total flight length, determine if there exist two movies that add up to the total length.Example:- Input: list=[]int{2, 3, 4}, length=6  Output: true, because there exists 2 and 4 that add up to 6Approach:- Could use hashmap to keep track of movie lengths that we've seen so far and  look it up as we iterate through the list.Cost:- O(n) time, O(n) space.Link to solution →2. Given a string, check if its permutation is a palindrome.Example:- Input: \"ivicc\"  Output: true- Input: \"civic\"  Output: trueApproach:- To determine if a permutation is a palindrome, need to check if each  character in the string appears an even number of times, allowing for  only one character to appear an odd time, that is the middle one.- Could use a hashmap store the characters and their number of occurrences.Cost:- O(n) time, O(1) space.Link to solution →3. Given a sentence (string), return its word count map.Example:- Input: \"Cliff finished his cake and paid the bill. Bill finished his cake at the edge of the cliff.\"  Output: map[string]int{\"cliff\": 1, \"Cliff\": 1, \"finished\": 2, \"his\": 2, \"cake\": 2, \"and\": 1, \"paid\": 1, \"the\": 3, \"bill\": 1, \"Bill\": 1, \"at\": 1, \"edge\": 1, \"of\": 1}Approach:- First get rid of special characters, then use a hashmap to keep counts of words  as we iterate through the string.Cost:- O(n) time, O(n) space.Link to solution →4. Given an unsorted list scores (integer) and a highest possible score (integer), return a sorted list utilizing that fact.Example:- Input: []int{37, 89, 41, 65, 91, 53}, 100  Output: []int{91, 89, 65, 53, 41, 37}Approach:- Utilize the highest score to allocate a fix-sized list ahead of time where  where its indices represent the scores themselves and its values represent  how many time these scores appear in the list.Cost:- O(n) time, O(n) space.Link to solution →  For more coding problems, please visit  https://github.com/hoanhan101/algo.  If you’re interested in getting updates for such content like these, consider  joining my mail list here →",
            "content_html": "<h3 id=\"1-given-a-list-of-movie-lengths-and-a-total-flight-length-determine-if-there-exist-two-movies-that-add-up-to-the-total-length\">1. Given a list of movie lengths and a total flight length, determine if there exist two movies that add up to the total length.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: list=[]int{2, 3, 4}, length=6  Output: true, because there exists 2 and 4 that add up to 6</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Could use hashmap to keep track of movie lengths that we've seen so far and  look it up as we iterate through the list.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(n) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/inflight_test.go\">Link to solution →</a></p><h3 id=\"2-given-a-string-check-if-its-permutation-is-a-palindrome\">2. Given a string, check if its permutation is a palindrome.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: \"ivicc\"  Output: true- Input: \"civic\"  Output: true</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- To determine if a permutation is a palindrome, need to check if each  character in the string appears an even number of times, allowing for  only one character to appear an odd time, that is the middle one.- Could use a hashmap store the characters and their number of occurrences.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/permutation_palindrome_test.go\">Link to solution →</a></p><h3 id=\"3-given-a-sentence-string-return-its-word-count-map\">3. Given a sentence (string), return its word count map.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: \"Cliff finished his cake and paid the bill. Bill finished his cake at the edge of the cliff.\"  Output: map[string]int{\"cliff\": 1, \"Cliff\": 1, \"finished\": 2, \"his\": 2, \"cake\": 2, \"and\": 1, \"paid\": 1, \"the\": 3, \"bill\": 1, \"Bill\": 1, \"at\": 1, \"edge\": 1, \"of\": 1}</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- First get rid of special characters, then use a hashmap to keep counts of words  as we iterate through the string.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(n) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/word_cloud_test.go\">Link to solution →</a></p><h3 id=\"4-given-an-unsorted-list-scores-integer-and-a-highest-possible-score-integer-return-a-sorted-list-utilizing-that-fact\">4. Given an unsorted list scores (integer) and a highest possible score (integer), return a sorted list utilizing that fact.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: []int{37, 89, 41, 65, 91, 53}, 100  Output: []int{91, 89, 65, 53, 41, 37}</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Utilize the highest score to allocate a fix-sized list ahead of time where  where its indices represent the scores themselves and its values represent  how many time these scores appear in the list.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(n) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/top_scores_test.go\">Link to solution →</a></p><blockquote>  <p>For more coding problems, please visit  <a href=\"https://github.com/hoanhan101/algo\">https://github.com/hoanhan101/algo</a>.</p></blockquote><blockquote>  <p>If you’re interested in getting updates for such content like these, consider  joining my <a href=\"https://tinyletter.com/hoanhan\">mail list here →</a></p></blockquote>",
            "url": "/2019/08/23/interview-cake-hashing-problems",
            
            
            
            "tags": ["interviewcake","algorithm"],
            
            "date_published": "2019-08-23T00:00:00-04:00",
            "date_modified": "2019-08-23T00:00:00-04:00",
            
                "author":  {
                "name": "Hoanh An",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "/2019/08/21/interviewcake-array-string-manipulation",
            "title": "Interview Cake's Array and string manipulation",
            "summary": null,
            "content_text": "1. Given a list of unsorted, independent meetings, returns a list of a merged one.Example:- Input: []meeting{ {1, 2}, {2, 3}, {4, 5} }  Output: []meeting{ {1, 3}, {4, 5} }- Input: []meeting{ {1, 5}, {2, 3} }  Output: []meeting{ {1, 5} }Approach:- Sort the list in ascending order so that meetings that might need to be  merged are next to each other.- Can merge two meetings together if the first one's end time is greater or  or equal than the second one's start time.Cost:- O(nlogn) time, O(n) space.- Because we sort all meeting first, the runtime is O(nlogn). We create a new  list of merged meeting times, so the space cost is O(n).Link to solution →2. Given a list of string, reverse its order.Example:- Input: []string{\"a\", \"b\", \"c\", \"d\"}  Output: []string{\"d\", \"c\", \"b\", \"a\"}Approach:- Use two pointers approach to swap two values on both ends as we move toward  the middle.Cost:- O(n) time, O(1) space.Link to solution →3. Given a list of string that is made up of word but in reverse, return the correct order in-place.Example:- Input: []string{\"w\", \"o\", \"r\", \"l\", \"d\", \"\", \"h\", \"e\", \"l\", \"l\", \"o\", \"\", \"s\", \"a\", \"y\"}  Output: []string{\"s\", \"a\", \"y\", \"\", \"h\", \"e\", \"l\", \"l\", \"o\", \"\", \"w\", \"o\", \"r\", \"l\", \"d\"}Approach:- Similar to reversing string, use the same idea to reverse all the characters  in the list first so that we could have a list of words in the right order, not  its characters.- Iterate through the list again and reverse its characters.Cost:- O(n) time, O(1) space.Link to solution →4. Merge two sorted arrays.Example:- Input: []int{1, 3, 5}, []int{2, 4, 6}  Output: []int{1, 2, 3, 4, 5, 6}- Input: []int{1, 3, 5}, []int{2, 4, 6, 7}  Output: []int{1, 2, 3, 4, 5, 6, 7}Approach:- Since these arrays are sorted, can use two pointers approach to iterate  through both of them and append the smaller value to a new merged list at  each step.Cost:- O(n) time, O(1) space.Link to solution →  For more coding problems, please visit  https://github.com/hoanhan101/algo.  If you’re interested in getting updates for such content like these, consider  joining my mail list here →",
            "content_html": "<h3 id=\"1-given-a-list-of-unsorted-independent-meetings-returns-a-list-of-a-merged-one\">1. Given a list of unsorted, independent meetings, returns a list of a merged one.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: []meeting{ {1, 2}, {2, 3}, {4, 5} }  Output: []meeting{ {1, 3}, {4, 5} }- Input: []meeting{ {1, 5}, {2, 3} }  Output: []meeting{ {1, 5} }</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Sort the list in ascending order so that meetings that might need to be  merged are next to each other.- Can merge two meetings together if the first one's end time is greater or  or equal than the second one's start time.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(nlogn) time, O(n) space.- Because we sort all meeting first, the runtime is O(nlogn). We create a new  list of merged meeting times, so the space cost is O(n).</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/merge_meetings_test.go\">Link to solution →</a></p><h3 id=\"2-given-a-list-of-string-reverse-its-order\">2. Given a list of string, reverse its order.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: []string{\"a\", \"b\", \"c\", \"d\"}  Output: []string{\"d\", \"c\", \"b\", \"a\"}</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Use two pointers approach to swap two values on both ends as we move toward  the middle.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/reverse_string_test.go\">Link to solution →</a></p><h3 id=\"3-given-a-list-of-string-that-is-made-up-of-word-but-in-reverse-return-the-correct-order-in-place\">3. Given a list of string that is made up of word but in reverse, return the correct order in-place.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: []string{\"w\", \"o\", \"r\", \"l\", \"d\", \"\", \"h\", \"e\", \"l\", \"l\", \"o\", \"\", \"s\", \"a\", \"y\"}  Output: []string{\"s\", \"a\", \"y\", \"\", \"h\", \"e\", \"l\", \"l\", \"o\", \"\", \"w\", \"o\", \"r\", \"l\", \"d\"}</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Similar to reversing string, use the same idea to reverse all the characters  in the list first so that we could have a list of words in the right order, not  its characters.- Iterate through the list again and reverse its characters.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/reverse_word_test.go\">Link to solution →</a></p><h3 id=\"4-merge-two-sorted-arrays\">4. Merge two sorted arrays.</h3><p>Example:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Input: []int{1, 3, 5}, []int{2, 4, 6}  Output: []int{1, 2, 3, 4, 5, 6}- Input: []int{1, 3, 5}, []int{2, 4, 6, 7}  Output: []int{1, 2, 3, 4, 5, 6, 7}</code></pre></div></div><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- Since these arrays are sorted, can use two pointers approach to iterate  through both of them and append the smaller value to a new merged list at  each step.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- O(n) time, O(1) space.</code></pre></div></div><p><a href=\"https://github.com/hoanhan101/algo/blob/master/interviewcake/merge_sorted_arrays_test.go\">Link to solution →</a></p><blockquote>  <p>For more coding problems, please visit  <a href=\"https://github.com/hoanhan101/algo\">https://github.com/hoanhan101/algo</a>.</p></blockquote><blockquote>  <p>If you’re interested in getting updates for such content like these, consider  joining my <a href=\"https://tinyletter.com/hoanhan\">mail list here →</a></p></blockquote>",
            "url": "/2019/08/21/interviewcake-array-string-manipulation",
            
            
            
            "tags": ["interviewcake","algorithm"],
            
            "date_published": "2019-08-21T00:00:00-04:00",
            "date_modified": "2019-08-21T00:00:00-04:00",
            
                "author":  {
                "name": "Hoanh An",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}