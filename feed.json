{
    "version": "https://jsonfeed.org/version/1",
    "title": "Gray - Single column blog and portfolio Jekyll theme",
    "home_page_url": "/",
    "feed_url": "/feed.json",
    "description": "Gray - Single column blog and portfolio Jekyll theme",
    "icon": "/apple-touch-icon.png",
    "favicon": "/favicon.ico",
    "expired": false,
    
    "author": "{"name"=>nil, "email"=>nil, "url"=>nil, "avatar"=>nil}",
    
"items": [
    
        {
            "id": "/2020/01/02/scalable-press",
            "title": "Scalable Press",
            "summary": null,
            "content_text": "What is the product?Efficient custom printing on demand.What is its current revenue (monthly, yearly)?100 millions a year.What is the business model?Subscription.How did the founder come up with their idea? What was the context?Had a friend, Raymond, working in the time T shirt business, Teespring, was booming. He also dropped out the same time, but because he had made 1 millions in revenue selling T shirts. Utilized cheap manufacturing, sold at 40% cheaper prices, were price leaders. Eric joined to build their own printing infrastructure to a even more automated, cheaper, efficient process.Built the API first and posted in Hackernews. Went after T shirt business, found Teechip, competed with Teespring (YC). Expanded to other industry too based on the API.How did they find the right problems to work on?TODOHow did they achieve product/market fit?TODOHow did they get their first paying customers?TODO",
            "content_html": "<h3 id=\"what-is-the-product\">What is the product?</h3><p>Efficient custom printing on demand.</p><h3 id=\"what-is-its-current-revenue-monthly-yearly\">What is its current revenue (monthly, yearly)?</h3><p>100 millions a year.</p><h3 id=\"what-is-the-business-model\">What is the business model?</h3><p>Subscription.</p><h3 id=\"how-did-the-founder-come-up-with-their-idea-what-was-the-context\">How did the founder come up with their idea? What was the context?</h3><p>Had a friend, Raymond, working in the time T shirt business, Teespring, was booming. He also dropped out the same time, but because he had made 1 millions in revenue selling T shirts. Utilized cheap manufacturing, sold at 40% cheaper prices, were price leaders. Eric joined to build their own printing infrastructure to a even more automated, cheaper, efficient process.</p><p>Built the API first and posted in Hackernews. Went after T shirt business, found Teechip, competed with Teespring (YC). Expanded to other industry too based on the API.</p><h3 id=\"how-did-they-find-the-right-problems-to-work-on\">How did they find the right problems to work on?</h3><p>TODO</p><h3 id=\"how-did-they-achieve-productmarket-fit\">How did they achieve product/market fit?</h3><p>TODO</p><h3 id=\"how-did-they-get-their-first-paying-customers\">How did they get their first paying customers?</h3><p>TODO</p>",
            "url": "/2020/01/02/scalable-press",
            
            
            
            
            
            "date_published": "2020-01-02T00:00:00-05:00",
            "date_modified": "2020-01-02T00:00:00-05:00",
            
                "author": 
                "{"name"=>nil, "email"=>nil, "url"=>nil, "avatar"=>nil}"
                
            
        },
    
        {
            "id": "/2019/09/24/7-sorting-algorithms",
            "title": "7 sorting algorithms",
            "summary": null,
            "content_text": "Here are 7 sorting algorithms implementations in Go that we are going to cover in this post:  Bubble Sort  Selection Sort  Insertion Sort  Merge Sort  Quicksort  Heapsort  Counting SortBubble SortApproach:Repeatedly swap the adjacent elements if they are in the wrong order in thearray, one item at a time.Cost:O(n^2) time and O(1) space.Solution:func bubbleSort(in []int) {\tlength := len(in)\t// for each element in the list, check it with almost every other element.\tfor i := 0; i &lt; length; i++ {\t\t// since the last i element is already in place, only iterate through\t\t// the item before the last one.\t\tfor j := 0; j &lt; length-i-1; j++ {\t\t\t// swap the adjacent elements if they are not in ascending order.\t\t\tif in[j] &gt; in[j+1] {\t\t\t\tcommon.Swap(in, j, j+1)\t\t\t}\t\t}\t}}Selection SortApproach:Repeatedly select the next smallest element from the unsorted array and move itto the front.Cost:O(n^2) time and O(1) space.Solution:func selectionSort(in []int) {\tminIndex := 0\tfor i := 0; i &lt; len(in)-1; i++ {\t\tminIndex = i\t\t// find the minimum in the rest of the array.\t\tfor j := i + 1; j &lt; len(in); j++ {\t\t\tif in[j] &lt; in[minIndex] {\t\t\t\tminIndex = j\t\t\t}\t\t}\t\t// swap the minimum value with the first value.\t\tcommon.Swap(in, i, minIndex)\t}}Insertion SortApproach:Insert elements from an unsorted array into a sorted subsection of thearray, one item at a time.Cost:O(n^2) time and O(1) space.Solution:func insertionSort(in []int) {\t// iterate through the list from position 1.\tfor i := 1; i &lt; len(in); i++ {\t\t// shift each one to the left by swapping it with the one before until\t\t// it's in the right spot.\t\tcurrent := in[i]\t\tj := i - 1\t\tfor j &gt;= 0 &amp;&amp; current &lt; in[j] {\t\t\tin[j+1] = in[j]\t\t\tj--\t\t}\t\tin[j+1] = current\t}}Merge SortApproach:Split the input in half, recursively sorts each half, then merge thesorted halves back together.Cost:O(nlogn) time and O(n) space.Solution:func mergeSort(in []int) []int {\t// base case\tif len(in) &lt;= 1 {\t\treturn in\t}\t// split the input in half.\tmiddleIndex := len(in) / 2\tleft := in[:middleIndex]\tright := in[middleIndex:]\t// sort each half.\tleftSorted := mergeSort(left)\trightSorted := mergeSort(right)\t// merge the sorted halves.\treturn mergeSortedArray(leftSorted, rightSorted)}func mergeSortedArray(a1, a2 []int) []int {\tout := []int{}\t// keep two \"pointer\" at index 0 and move up accordingly as one get\t// merged in.\ti, j := 0, 0\tfor i &lt; len(a1) &amp;&amp; j &lt; len(a2) {\t\tif a1[i] &lt; a2[j] {\t\t\tout = append(out, a1[i])\t\t\ti++\t\t} else {\t\t\tout = append(out, a2[j])\t\t\tj++\t\t}\t}\t// if we get here, one array must have bigger size than the other. could\t// figure out which one is it then copy the rest of its to our final one.\tif i &lt; len(a1) {\t\tout = append(out, a1[i:]...)\t}\tif j &lt; len(a2) {\t\tout = append(out, a2[j:]...)\t}\treturn out}QuicksortApproach:Recursively divide the input into two smaller arrays around a pivot, whereone half has items smaller than the pivot, other half has items bigger thanthe pivot.Cost:O(nlogn) time and O(nlogn) space.Solution:func quicksort(in []int, start, end int) {\tif start &lt; end {\t\t// pi is the pivot/partition index.\t\tpi := partition(in, start, end)\t\t// sort the items before and after partition.\t\tquicksort(in, start, pi-1)\t\tquicksort(in, pi+1, end)\t}}func partition(in []int, start, end int) int {\tpivot := in[end]\tleft := start\tright := end - 1\tfor left &lt;= right {\t\t// keep going until we find something on the left that belongs to the\t\t// right.\t\tfor left &lt;= end &amp;&amp; in[left] &lt; pivot {\t\t\tleft++\t\t}\t\t// keep going until we find something on the right that belongs to the\t\t// left.\t\tfor right &gt;= start &amp;&amp; in[right] &gt;= pivot {\t\t\tright--\t\t}\t\t// by swapping the item at left and right index, we move the item that\t\t// is smaller than the pivot to the left half and vice versa.\t\tif left &lt; right {\t\t\tcommon.Swap(in, left, right)\t\t} else {\t\t\t// once the partition is finished, move the pivot back to its final\t\t\t// position by swapping the item at left and end index.\t\t\tcommon.Swap(in, left, end)\t\t}\t}\treturn left}HeapsortApproach:Similar to selection sort, repeatedly choose the largest item and move it tothe end of the array using a max heap.Cost:O(nlogn) time and O(1) space.Solution:func heapsort(in []int) {\theapify(in)\tsize := len(in)\tfor size &gt; 0 {\t\t// repeatedly remove the largest item.\t\tlargest := removeLargest(in, size)\t\t// update the heap size.\t\tsize--\t\t// store the removed value at the end of the list.\t\tin[size] = largest\t}}// heapify transform the input into a max heap.func heapify(in []int) {\tfor i := len(in) - 1; i &gt; -1; i-- {\t\tbubbleDown(in, len(in), i)\t}}// bubbleDown allow larger values to reach the top.func bubbleDown(heap []int, heapSize int, index int) {\tfor index &lt; heapSize {\t\t// fast-calculate the children left and right index.\t\tleft := index*2 + 1\t\tright := index*2 + 2\t\t// stop if there is no child node.\t\tif left &gt;= heapSize {\t\t\tbreak\t\t}\t\t// find the larger index\t\tlarger := left\t\tif right &lt; heapSize &amp;&amp; heap[left] &lt; heap[right] {\t\t\tlarger = right\t\t}\t\t// if the current item is larger than both children, we're done.\t\t// if not, swap with the larger child.\t\tif heap[index] &lt; heap[larger] {\t\t\tcommon.Swap(heap, index, larger)\t\t} else {\t\t\tbreak\t\t}\t}}// removeLargest remove and return the largest item from the heap.func removeLargest(heap []int, heapSize int) int {\t// largest item is at the top of our max heap.\tlargest := heap[0]\t// move the last item into the root position.\theap[0] = heap[heapSize-1]\t// bubble down from the root to restore the heap.\tbubbleDown(heap, heapSize-1, 0)\treturn largest}Counting SortApproach:Iterate through the input, count the number of times each item occurs, usethese counts to compute each item's index in the final sorted array.Cost:O(n) time and O(n) space.Solution:func countingSort(in []int, max int) []int {\t// utilize max value to create a fix-sized list of item counts.\tcounts := make([]int, max+1)\tout := make([]int, 0)\t// populate the array where its indices represent items themselves and\t// its values represent how many time the item appears.\tfor _, item := range in {\t\tcounts[item]++\t}\t// iterate through the counts and add the item to the output list.\tfor i := 0; i &lt; len(counts); i++ {\t\tcount := counts[i]\t\tfor j := 0; j &lt; count; j++ {\t\t\tout = append(out, i)\t\t}\t}\treturn out}  For more coding problems, please visit  https://github.com/hoanhan101/algo.  If you’re interested in getting updates for these content like this, consider  joining my mail list here →",
            "content_html": "<p>Here are 7 sorting algorithms implementations in Go that we are going to cover in this post:</p><ol>  <li>Bubble Sort</li>  <li>Selection Sort</li>  <li>Insertion Sort</li>  <li>Merge Sort</li>  <li>Quicksort</li>  <li>Heapsort</li>  <li>Counting Sort</li></ol><h2 id=\"bubble-sort\">Bubble Sort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Repeatedly swap the adjacent elements if they are in the wrong order in thearray, one item at a time.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(n^2) time and O(1) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">bubbleSort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"n\">length</span> <span class=\"o\">:=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span>\t<span class=\"c\">// for each element in the list, check it with almost every other element.</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// since the last i element is already in place, only iterate through</span>\t\t<span class=\"c\">// the item before the last one.</span>\t\t<span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span><span class=\"o\">-</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t\t<span class=\"c\">// swap the adjacent elements if they are not in ascending order.</span>\t\t\t<span class=\"k\">if</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t\t<span class=\"n\">common</span><span class=\"o\">.</span><span class=\"n\">Swap</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"p\">,</span> <span class=\"n\">j</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">)</span>\t\t\t<span class=\"p\">}</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"selection-sort\">Selection Sort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Repeatedly select the next smallest element from the unsorted array and move itto the front.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(n^2) time and O(1) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">selectionSort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"n\">minIndex</span> <span class=\"o\">:=</span> <span class=\"m\">0</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t<span class=\"n\">minIndex</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\t\t<span class=\"c\">// find the minimum in the rest of the array.</span>\t\t<span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">);</span> <span class=\"n\">j</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t\t<span class=\"k\">if</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">minIndex</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t\t<span class=\"n\">minIndex</span> <span class=\"o\">=</span> <span class=\"n\">j</span>\t\t\t<span class=\"p\">}</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"c\">// swap the minimum value with the first value.</span>\t\t<span class=\"n\">common</span><span class=\"o\">.</span><span class=\"n\">Swap</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">minIndex</span><span class=\"p\">)</span>\t<span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"insertion-sort\">Insertion Sort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Insert elements from an unsorted array into a sorted subsection of thearray, one item at a time.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(n^2) time and O(1) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">insertionSort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"c\">// iterate through the list from position 1.</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">);</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// shift each one to the left by swapping it with the one before until</span>\t\t<span class=\"c\">// it's in the right spot.</span>\t\t<span class=\"n\">current</span> <span class=\"o\">:=</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\t\t<span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"m\">1</span>\t\t<span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">&gt;=</span> <span class=\"m\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">current</span> <span class=\"o\">&lt;</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span>\t\t\t<span class=\"n\">j</span><span class=\"o\">--</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">current</span>\t<span class=\"p\">}</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"merge-sort\">Merge Sort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Split the input in half, recursively sorts each half, then merge thesorted halves back together.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(nlogn) time and O(n) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">mergeSort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">[]</span><span class=\"kt\">int</span> <span class=\"p\">{</span>\t<span class=\"c\">// base case</span>\t<span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span> <span class=\"o\">&lt;=</span> <span class=\"m\">1</span> <span class=\"p\">{</span>\t\t<span class=\"k\">return</span> <span class=\"n\">in</span>\t<span class=\"p\">}</span>\t<span class=\"c\">// split the input in half.</span>\t<span class=\"n\">middleIndex</span> <span class=\"o\">:=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"m\">2</span>\t<span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"o\">:</span><span class=\"n\">middleIndex</span><span class=\"p\">]</span>\t<span class=\"n\">right</span> <span class=\"o\">:=</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">middleIndex</span><span class=\"o\">:</span><span class=\"p\">]</span>\t<span class=\"c\">// sort each half.</span>\t<span class=\"n\">leftSorted</span> <span class=\"o\">:=</span> <span class=\"n\">mergeSort</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">)</span>\t<span class=\"n\">rightSorted</span> <span class=\"o\">:=</span> <span class=\"n\">mergeSort</span><span class=\"p\">(</span><span class=\"n\">right</span><span class=\"p\">)</span>\t<span class=\"c\">// merge the sorted halves.</span>\t<span class=\"k\">return</span> <span class=\"n\">mergeSortedArray</span><span class=\"p\">(</span><span class=\"n\">leftSorted</span><span class=\"p\">,</span> <span class=\"n\">rightSorted</span><span class=\"p\">)</span><span class=\"p\">}</span><span class=\"k\">func</span> <span class=\"n\">mergeSortedArray</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a2</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">[]</span><span class=\"kt\">int</span> <span class=\"p\">{</span>\t<span class=\"n\">out</span> <span class=\"o\">:=</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">{}</span>\t<span class=\"c\">// keep two \"pointer\" at index 0 and move up accordingly as one get</span>\t<span class=\"c\">// merged in.</span>\t<span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">,</span> <span class=\"m\">0</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">a2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t\t<span class=\"k\">if</span> <span class=\"n\">a1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"nb\">append</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\t\t\t<span class=\"n\">i</span><span class=\"o\">++</span>\t\t<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"nb\">append</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">])</span>\t\t\t<span class=\"n\">j</span><span class=\"o\">++</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span>\t<span class=\"c\">// if we get here, one array must have bigger size than the other. could</span>\t<span class=\"c\">// figure out which one is it then copy the rest of its to our final one.</span>\t<span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t\t<span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"nb\">append</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"p\">]</span><span class=\"o\">...</span><span class=\"p\">)</span>\t<span class=\"p\">}</span>\t<span class=\"k\">if</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">a2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t\t<span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"nb\">append</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"o\">:</span><span class=\"p\">]</span><span class=\"o\">...</span><span class=\"p\">)</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"n\">out</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"quicksort\">Quicksort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Recursively divide the input into two smaller arrays around a pivot, whereone half has items smaller than the pivot, other half has items bigger thanthe pivot.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(nlogn) time and O(nlogn) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">quicksort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"k\">if</span> <span class=\"n\">start</span> <span class=\"o\">&lt;</span> <span class=\"n\">end</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// pi is the pivot/partition index.</span>\t\t<span class=\"n\">pi</span> <span class=\"o\">:=</span> <span class=\"n\">partition</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">)</span>\t\t<span class=\"c\">// sort the items before and after partition.</span>\t\t<span class=\"n\">quicksort</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">pi</span><span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">)</span>\t\t<span class=\"n\">quicksort</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">pi</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">)</span>\t<span class=\"p\">}</span><span class=\"p\">}</span><span class=\"k\">func</span> <span class=\"n\">partition</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"kt\">int</span> <span class=\"p\">{</span>\t<span class=\"n\">pivot</span> <span class=\"o\">:=</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">end</span><span class=\"p\">]</span>\t<span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"n\">start</span>\t<span class=\"n\">right</span> <span class=\"o\">:=</span> <span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"m\">1</span>\t<span class=\"k\">for</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">right</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// keep going until we find something on the left that belongs to the</span>\t\t<span class=\"c\">// right.</span>\t\t<span class=\"k\">for</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"n\">end</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">left</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">pivot</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">left</span><span class=\"o\">++</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"c\">// keep going until we find something on the right that belongs to the</span>\t\t<span class=\"c\">// left.</span>\t\t<span class=\"k\">for</span> <span class=\"n\">right</span> <span class=\"o\">&gt;=</span> <span class=\"n\">start</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">right</span><span class=\"p\">]</span> <span class=\"o\">&gt;=</span> <span class=\"n\">pivot</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">right</span><span class=\"o\">--</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"c\">// by swapping the item at left and right index, we move the item that</span>\t\t<span class=\"c\">// is smaller than the pivot to the left half and vice versa.</span>\t\t<span class=\"k\">if</span> <span class=\"n\">left</span> <span class=\"o\">&lt;</span> <span class=\"n\">right</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">common</span><span class=\"o\">.</span><span class=\"n\">Swap</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">)</span>\t\t<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\t\t\t<span class=\"c\">// once the partition is finished, move the pivot back to its final</span>\t\t\t<span class=\"c\">// position by swapping the item at left and end index.</span>\t\t\t<span class=\"n\">common</span><span class=\"o\">.</span><span class=\"n\">Swap</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">)</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"n\">left</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"heapsort\">Heapsort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Similar to selection sort, repeatedly choose the largest item and move it tothe end of the array using a max heap.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(nlogn) time and O(1) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">heapsort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"n\">heapify</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span>\t<span class=\"n\">size</span> <span class=\"o\">:=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span>\t<span class=\"k\">for</span> <span class=\"n\">size</span> <span class=\"o\">&gt;</span> <span class=\"m\">0</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// repeatedly remove the largest item.</span>\t\t<span class=\"n\">largest</span> <span class=\"o\">:=</span> <span class=\"n\">removeLargest</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"p\">)</span>\t\t<span class=\"c\">// update the heap size.</span>\t\t<span class=\"n\">size</span><span class=\"o\">--</span>\t\t<span class=\"c\">// store the removed value at the end of the list.</span>\t\t<span class=\"n\">in</span><span class=\"p\">[</span><span class=\"n\">size</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">largest</span>\t<span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c\">// heapify transform the input into a max heap.</span><span class=\"k\">func</span> <span class=\"n\">heapify</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">--</span> <span class=\"p\">{</span>\t\t<span class=\"n\">bubbleDown</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">),</span> <span class=\"n\">i</span><span class=\"p\">)</span>\t<span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c\">// bubbleDown allow larger values to reach the top.</span><span class=\"k\">func</span> <span class=\"n\">bubbleDown</span><span class=\"p\">(</span><span class=\"n\">heap</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">heapSize</span> <span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">index</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\t<span class=\"k\">for</span> <span class=\"n\">index</span> <span class=\"o\">&lt;</span> <span class=\"n\">heapSize</span> <span class=\"p\">{</span>\t\t<span class=\"c\">// fast-calculate the children left and right index.</span>\t\t<span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"n\">index</span><span class=\"o\">*</span><span class=\"m\">2</span> <span class=\"o\">+</span> <span class=\"m\">1</span>\t\t<span class=\"n\">right</span> <span class=\"o\">:=</span> <span class=\"n\">index</span><span class=\"o\">*</span><span class=\"m\">2</span> <span class=\"o\">+</span> <span class=\"m\">2</span>\t\t<span class=\"c\">// stop if there is no child node.</span>\t\t<span class=\"k\">if</span> <span class=\"n\">left</span> <span class=\"o\">&gt;=</span> <span class=\"n\">heapSize</span> <span class=\"p\">{</span>\t\t\t<span class=\"k\">break</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"c\">// find the larger index</span>\t\t<span class=\"n\">larger</span> <span class=\"o\">:=</span> <span class=\"n\">left</span>\t\t<span class=\"k\">if</span> <span class=\"n\">right</span> <span class=\"o\">&lt;</span> <span class=\"n\">heapSize</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"n\">left</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"n\">right</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">larger</span> <span class=\"o\">=</span> <span class=\"n\">right</span>\t\t<span class=\"p\">}</span>\t\t<span class=\"c\">// if the current item is larger than both children, we're done.</span>\t\t<span class=\"c\">// if not, swap with the larger child.</span>\t\t<span class=\"k\">if</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"n\">larger</span><span class=\"p\">]</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">common</span><span class=\"o\">.</span><span class=\"n\">Swap</span><span class=\"p\">(</span><span class=\"n\">heap</span><span class=\"p\">,</span> <span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">larger</span><span class=\"p\">)</span>\t\t<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\t\t\t<span class=\"k\">break</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span><span class=\"p\">}</span><span class=\"c\">// removeLargest remove and return the largest item from the heap.</span><span class=\"k\">func</span> <span class=\"n\">removeLargest</span><span class=\"p\">(</span><span class=\"n\">heap</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">heapSize</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"kt\">int</span> <span class=\"p\">{</span>\t<span class=\"c\">// largest item is at the top of our max heap.</span>\t<span class=\"n\">largest</span> <span class=\"o\">:=</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"p\">]</span>\t<span class=\"c\">// move the last item into the root position.</span>\t<span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"n\">heapSize</span><span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">]</span>\t<span class=\"c\">// bubble down from the root to restore the heap.</span>\t<span class=\"n\">bubbleDown</span><span class=\"p\">(</span><span class=\"n\">heap</span><span class=\"p\">,</span> <span class=\"n\">heapSize</span><span class=\"o\">-</span><span class=\"m\">1</span><span class=\"p\">,</span> <span class=\"m\">0</span><span class=\"p\">)</span>\t<span class=\"k\">return</span> <span class=\"n\">largest</span><span class=\"p\">}</span></code></pre></div></div><h2 id=\"counting-sort\">Counting Sort</h2><p>Approach:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Iterate through the input, count the number of times each item occurs, usethese counts to compute each item's index in the final sorted array.</code></pre></div></div><p>Cost:</p><div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>O(n) time and O(n) space.</code></pre></div></div><p>Solution:</p><div class=\"language-go highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">func</span> <span class=\"n\">countingSort</span><span class=\"p\">(</span><span class=\"n\">in</span> <span class=\"p\">[]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">max</span> <span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">[]</span><span class=\"kt\">int</span> <span class=\"p\">{</span>\t<span class=\"c\">// utilize max value to create a fix-sized list of item counts.</span>\t<span class=\"n\">counts</span> <span class=\"o\">:=</span> <span class=\"nb\">make</span><span class=\"p\">([]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">max</span><span class=\"o\">+</span><span class=\"m\">1</span><span class=\"p\">)</span>\t<span class=\"n\">out</span> <span class=\"o\">:=</span> <span class=\"nb\">make</span><span class=\"p\">([]</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"m\">0</span><span class=\"p\">)</span>\t<span class=\"c\">// populate the array where its indices represent items themselves and</span>\t<span class=\"c\">// its values represent how many time the item appears.</span>\t<span class=\"k\">for</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">item</span> <span class=\"o\">:=</span> <span class=\"k\">range</span> <span class=\"n\">in</span> <span class=\"p\">{</span>\t\t<span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">item</span><span class=\"p\">]</span><span class=\"o\">++</span>\t<span class=\"p\">}</span>\t<span class=\"c\">// iterate through the counts and add the item to the output list.</span>\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">counts</span><span class=\"p\">);</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t<span class=\"n\">count</span> <span class=\"o\">:=</span> <span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\t\t<span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"m\">0</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">count</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span> <span class=\"p\">{</span>\t\t\t<span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"nb\">append</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">)</span>\t\t<span class=\"p\">}</span>\t<span class=\"p\">}</span>\t<span class=\"k\">return</span> <span class=\"n\">out</span><span class=\"p\">}</span></code></pre></div></div><blockquote>  <p>For more coding problems, please visit  <a href=\"https://github.com/hoanhan101/algo\">https://github.com/hoanhan101/algo</a>.</p></blockquote><blockquote>  <p>If you’re interested in getting updates for these content like this, consider  joining my <a href=\"https://tinyletter.com/hoanhan\">mail list here →</a></p></blockquote>",
            "url": "/2019/09/24/7-sorting-algorithms",
            
            
            
            "tags": ["algorithm","sorting"],
            
            "date_published": "2019-09-24T00:00:00-04:00",
            "date_modified": "2019-09-24T00:00:00-04:00",
            
                "author": 
                "{"name"=>nil, "email"=>nil, "url"=>nil, "avatar"=>nil}"
                
            
        }
    
    ]
}